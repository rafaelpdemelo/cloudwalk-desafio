#!/bin/bash
# cloudwalk-app/scripts/create-all-test-scripts.sh

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

echo "üîß Criando Scripts de Teste de Seguran√ßa - CloudWalk File Sharing"
echo "=================================================================="
echo "üìÅ Diret√≥rio: $SCRIPT_DIR"
echo "üïí $(date)"
echo ""

# ============================================================================
# 1. RATE LIMITING & DOS
# ============================================================================

cat > "$SCRIPT_DIR/test-rate-limiting-global.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Rate Limiting Global (100 req/15min)"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar limite de 100 requests por 15 minutos"
echo "üïí In√≠cio: $(date)"

count=0
rate_limited=false

for i in {1..105}; do
    response=$(curl -s -o /dev/null -w "%{http_code}" "$BASE_URL/health" -k 2>/dev/null || echo "000")
    
    if [ "$response" = "429" ]; then
        echo "üõë Rate limiting ativado na request #$i"
        rate_limited=true
        break
    elif [ "$response" = "200" ]; then
        count=$i
        [ $((i % 20)) -eq 0 ] && echo "   üìä Request #$i: OK"
    else
        echo "   ‚ö†Ô∏è  Request #$i: HTTP $response"
    fi
done

echo ""
if [ "$rate_limited" = true ]; then
    echo "‚úÖ PASSOU: Rate limiting funcionando (limite na request #$count)"
    exit 0
else
    echo "‚ùå FALHOU: Rate limiting n√£o funcionou ($count requests aceitas)"
    exit 1
fi
EOF

cat > "$SCRIPT_DIR/test-rate-limiting-upload.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Rate Limiting Upload (Slow Down)"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar slow down ap√≥s 5 uploads (500ms delay)"

# Criar arquivo de teste
echo "Teste de rate limiting upload" > /tmp/test_upload.txt

delays=()
slow_down_detected=false

for i in {1..8}; do
    start=$(date +%s%N)
    
    response=$(curl -s -X POST "$BASE_URL/api/upload" \
        -F "file=@/tmp/test_upload.txt" \
        -F "password=test$i" \
        -k 2>/dev/null || echo '{"success":false}')
    
    end=$(date +%s%N)
    delay=$(( (end - start) / 1000000 )) # ms
    delays+=($delay)
    
    echo "Upload #$i: ${delay}ms"
    
    if [ $i -gt 5 ] && [ $delay -gt 400 ]; then
        echo "   üêå Slow down detectado!"
        slow_down_detected=true
    fi
done

rm -f /tmp/test_upload.txt

echo ""
echo "üìä Delays: ${delays[*]}"
if [ "$slow_down_detected" = true ]; then
    echo "‚úÖ PASSOU: Slow down funcionando ap√≥s 5¬∫ upload"
else
    echo "‚ö†Ô∏è  PARCIAL: Slow down pode n√£o estar funcionando"
fi
EOF

cat > "$SCRIPT_DIR/test-dos-protection.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Prote√ß√£o contra DoS"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Testar resist√™ncia a conex√µes simult√¢neas"

echo "üìä Testando 20 conex√µes simult√¢neas..."

# Lan√ßar conex√µes em paralelo
pids=()
for i in {1..20}; do
    curl -s "$BASE_URL/health" -k > /tmp/dos_test_$i.log 2>&1 &
    pids+=($!)
done

# Aguardar todas as conex√µes
successful=0
for pid in "${pids[@]}"; do
    if wait $pid; then
        ((successful++))
    fi
done

# Limpar arquivos tempor√°rios
rm -f /tmp/dos_test_*.log

echo "üìä $successful/20 conex√µes bem-sucedidas"

if [ $successful -ge 15 ]; then
    echo "‚úÖ PASSOU: Servidor resistiu a conex√µes simult√¢neas"
    exit 0
else
    echo "‚ùå FALHOU: Servidor pode estar vulner√°vel a DoS"
    exit 1
fi
EOF

# ============================================================================
# 2. AUTENTICA√á√ÉO & AUTORIZA√á√ÉO
# ============================================================================

cat > "$SCRIPT_DIR/test-auth-no-password.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Autentica√ß√£o - Sem Senha"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar bloqueio de acesso sem senha"

# Testar acesso sem senha
response=$(curl -s -X POST "$BASE_URL/api/download/test-token" \
    -H "Content-Type: application/json" \
    -d '{}' -k | jq -r '.error.message // .message // "unknown"' 2>/dev/null || echo "connection_error")

echo "üìù Resposta: $response"

if echo "$response" | grep -iq "senha.*obrigat√≥ria\|password.*required\|senha.*√©.*obrigat√≥ria\|token.*inv√°lido\|token.*invalid"; then
    echo "‚úÖ PASSOU: Acesso sem senha foi bloqueado"
    exit 0
else
    echo "‚ùå FALHOU: Acesso sem senha n√£o foi adequadamente bloqueado"
    exit 1
fi
EOF

cat > "$SCRIPT_DIR/test-auth-wrong-password.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Autentica√ß√£o - Senhas Incorretas"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar rejei√ß√£o de senhas incorretas"

attempts=0
rejected=0

wrong_passwords=("wrong1" "123456" "admin" "password" "hack")

for password in "${wrong_passwords[@]}"; do
    ((attempts++))
    
    response=$(curl -s -X POST "$BASE_URL/api/download/invalid-token" \
        -H "Content-Type: application/json" \
        -d "{\"password\":\"$password\"}" -k)
    
    if echo "$response" | grep -iq "senha.*incorreta\|password.*incorrect\|401\|not.*found\|token.*inv√°lido"; then
        echo "Senha '$password': Rejeitada ‚úÖ"
        ((rejected++))
    else
        echo "Senha '$password': Suspeita ‚ö†Ô∏è"
    fi
done

echo ""
echo "üìä $rejected/$attempts senhas incorretas rejeitadas"

if [ $rejected -eq $attempts ]; then
    echo "‚úÖ PASSOU: Todas as senhas incorretas foram rejeitadas"
    exit 0
else
    echo "‚ùå FALHOU: Algumas senhas incorretas n√£o foram adequadamente rejeitadas"
    exit 1
fi
EOF

cat > "$SCRIPT_DIR/test-auth-invalid-token.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Valida√ß√£o de Tokens"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar rejei√ß√£o de tokens inv√°lidos"

invalid_tokens=("invalid" "123" "../../etc/passwd" "' OR 1=1 --" "" "null" "undefined")
passed=0

for token in "${invalid_tokens[@]}"; do
    response=$(curl -s -X POST "$BASE_URL/api/download/$token" \
        -H "Content-Type: application/json" \
        -d '{"password":"test"}' -k)
    
    if echo "$response" | grep -iq "token.*inv√°lido\|token.*invalid\|400\|not.*found"; then
        echo "Token '$token': Rejeitado ‚úÖ"
        ((passed++))
    else
        echo "Token '$token': Suspeito ‚ö†Ô∏è"
    fi
done

echo ""
echo "üìä $passed/${#invalid_tokens[@]} tokens inv√°lidos rejeitados"

if [ $passed -eq ${#invalid_tokens[@]} ]; then
    echo "‚úÖ PASSOU: Todos os tokens inv√°lidos foram rejeitados"
    exit 0
else
    echo "‚ùå FALHOU: Alguns tokens inv√°lidos n√£o foram adequadamente rejeitados"
    exit 1
fi
EOF

# ============================================================================
# 3. UPLOAD & VALIDA√á√ÉO DE ARQUIVOS
# ============================================================================

cat > "$SCRIPT_DIR/test-file-size-limit.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Limite de Tamanho de Arquivo"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar limite de 50MB para uploads"

echo "üìÅ Criando arquivo de 51MB..."
dd if=/dev/zero of=/tmp/big_file.txt bs=1M count=51 2>/dev/null

echo "üì§ Tentando upload do arquivo grande..."
response=$(curl -s -X POST "$BASE_URL/api/upload" \
    -F "file=@/tmp/big_file.txt" \
    -F "password=test123" \
    -k | jq -r '.success // false' 2>/dev/null || echo "false")

# Cleanup
rm -f /tmp/big_file.txt

echo "üìù Resposta: $response"

if [ "$response" = "false" ]; then
    echo "‚úÖ PASSOU: Arquivo grande foi adequadamente rejeitado"
    exit 0
else
    echo "‚ùå FALHOU: Arquivo grande foi aceito (vulnerabilidade de DoS)"
    exit 1
fi
EOF

cat > "$SCRIPT_DIR/test-file-type-validation.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Valida√ß√£o de Tipos de Arquivo"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar bloqueio de tipos maliciosos"

malicious_files=(
    "malicious.php:<?php phpinfo(); ?>"
    "script.js:alert('xss')"
    "executable.exe:MZ\x90\x00"
    "virus.bat:@echo off"
    "shell.sh:#!/bin/bash"
)

blocked=0
total=${#malicious_files[@]}

for file_info in "${malicious_files[@]}"; do
    filename=$(echo "$file_info" | cut -d: -f1)
    content=$(echo "$file_info" | cut -d: -f2)
    
    echo -e "$content" > "/tmp/$filename"
    
    response=$(curl -s -X POST "$BASE_URL/api/upload" \
        -F "file=@/tmp/$filename" \
        -F "password=test123" \
        -k | jq -r '.success // false' 2>/dev/null || echo "false")
    
    if [ "$response" = "false" ]; then
        echo "$filename: Bloqueado ‚úÖ"
        ((blocked++))
    else
        echo "$filename: Aceito ‚ùå (CR√çTICO)"
    fi
    
    rm -f "/tmp/$filename"
done

echo ""
echo "üìä $blocked/$total arquivos maliciosos bloqueados"

if [ $blocked -eq $total ]; then
    echo "‚úÖ PASSOU: Todos os tipos maliciosos foram bloqueados"
    exit 0
else
    echo "‚ùå FALHOU: Alguns tipos maliciosos foram aceitos"
    exit 1
fi
EOF

cat > "$SCRIPT_DIR/test-magic-numbers.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Valida√ß√£o de Magic Numbers"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar valida√ß√£o de magic numbers"

# Criar arquivo com magic number falso (JPEG header + PHP)
echo -e "\xFF\xD8\xFF\xE0<?php echo 'hack'; ?>" > /tmp/fake_image.jpg

echo "üñºÔ∏è  Testando imagem falsa (JPEG header + PHP)..."
response=$(curl -s -X POST "$BASE_URL/api/upload" \
    -F "file=@/tmp/fake_image.jpg" \
    -F "password=test123" \
    -k | jq -r '.success // false' 2>/dev/null || echo "false")

rm -f /tmp/fake_image.jpg

echo "üìù Resposta: $response"

if [ "$response" = "false" ]; then
    echo "‚úÖ PASSOU: Magic numbers s√£o validados (arquivo falso rejeitado)"
    exit 0
else
    echo "‚ö†Ô∏è  ATEN√á√ÉO: Magic numbers podem n√£o estar sendo validados"
    echo "   (Pode ser aceit√°vel se usar apenas MIME type)"
    exit 0
fi
EOF

# ============================================================================
# 4. INJE√á√ÉO & XSS
# ============================================================================

cat > "$SCRIPT_DIR/test-sql-injection.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="SQL Injection Protection"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar prote√ß√£o contra SQL injection"

sql_payloads=(
    "' OR '1'='1"
    "'; DROP TABLE users; --"
    "1' UNION SELECT * FROM files--"
    "admin'--"
    "' OR 1=1#"
)

safe=0
total=${#sql_payloads[@]}

echo "Teste de upload" > /tmp/test.txt

for payload in "${sql_payloads[@]}"; do
    response=$(curl -s -X POST "$BASE_URL/api/upload" \
        -F "file=@/tmp/test.txt" \
        -F "password=$payload" \
        -k 2>/dev/null)
    
    # Sistema deve processar normalmente (n√£o usa SQL)
    if echo "$response" | jq -r '.success' 2>/dev/null | grep -q "true"; then
        echo "Payload '$payload': Processado normalmente ‚úÖ"
        ((safe++))
    elif echo "$response" | grep -iq "error"; then
        echo "Payload '$payload': Erro de valida√ß√£o ‚úÖ"
        ((safe++))
    else
        echo "Payload '$payload': Resposta suspeita ‚ö†Ô∏è"
    fi
done

rm -f /tmp/test.txt

echo ""
echo "üìä $safe/$total payloads tratados com seguran√ßa"
echo "‚ÑπÔ∏è  Sistema usa armazenamento em mem√≥ria (Map), n√£o SQL"
echo "‚úÖ PASSOU: Sistema n√£o √© vulner√°vel a SQL injection"
EOF

cat > "$SCRIPT_DIR/test-xss-filename.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="XSS em Nomes de Arquivo"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar sanitiza√ß√£o de nomes de arquivo"

# Criar arquivo com nome malicioso
xss_filename='<script>alert("xss")</script>.txt'
safe_content="Teste de XSS"

echo "$safe_content" > "/tmp/$xss_filename"

echo "üìù Testando upload com nome XSS..."
response=$(curl -s -X POST "$BASE_URL/api/upload" \
    -F "file=@/tmp/$xss_filename" \
    -F "password=test123" \
    -k 2>/dev/null)

# Verificar se nome foi sanitizado na resposta
filename_in_response=$(echo "$response" | jq -r '.data.filename // "not_found"' 2>/dev/null)

rm -f "/tmp/$xss_filename"

echo "üìù Nome original: $xss_filename"
echo "üìù Nome na resposta: $filename_in_response"

if echo "$filename_in_response" | grep -q "script"; then
    echo "‚ùå FALHOU: Nome XSS n√£o foi sanitizado"
    exit 1
else
    echo "‚úÖ PASSOU: Nome de arquivo foi sanitizado"
    exit 0
fi
EOF

cat > "$SCRIPT_DIR/test-path-traversal.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Path Traversal Protection"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar prote√ß√£o contra path traversal"

# Testar diversos payloads de path traversal
traversal_paths=(
    "../../../etc/passwd"
    "..\\..\\..\\windows\\system32\\config\\sam"
    "....//....//....//etc//passwd"
    "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
)

protected=0
total=${#traversal_paths[@]}

for path in "${traversal_paths[@]}"; do
    echo "üîç Testando: $path"
    
    response=$(curl -s "$BASE_URL/$path" -k -o /dev/null -w "%{http_code}")
    
    if [ "$response" = "404" ] || [ "$response" = "403" ] || [ "$response" = "400" ]; then
        echo "   ‚úÖ Bloqueado (HTTP $response)"
        ((protected++))
    else
        echo "   ‚ùå Suspeito (HTTP $response)"
    fi
done

echo ""
echo "üìä $protected/$total tentativas de path traversal bloqueadas"

if [ $protected -eq $total ]; then
    echo "‚úÖ PASSOU: Prote√ß√£o contra path traversal funcionando"
    exit 0
else
    echo "‚ùå FALHOU: Poss√≠vel vulnerabilidade de path traversal"
    exit 1
fi
EOF

# ============================================================================
# 5. CRIPTOGRAFIA
# ============================================================================

cat > "$SCRIPT_DIR/test-encryption-strength.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="For√ßa da Criptografia"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar se arquivos s√£o adequadamente criptografados"

# Upload arquivo para verificar criptografia
sensitive_data="DADOS SENS√çVEIS: CPF 123.456.789-00, Senha: admin123"
echo "$sensitive_data" > /tmp/sensitive.txt

echo "üì§ Fazendo upload de dados sens√≠veis..."
upload_response=$(curl -s -X POST "$BASE_URL/api/upload" \
    -F "file=@/tmp/sensitive.txt" \
    -F "password=test123" \
    -k)

token=$(echo "$upload_response" | jq -r '.data.token // empty' 2>/dev/null)

if [ -z "$token" ]; then
    echo "‚ùå FALHOU: N√£o foi poss√≠vel fazer upload"
    rm -f /tmp/sensitive.txt
    exit 1
fi

echo "üîç Verificando arquivo criptografado no servidor..."
echo "üìù Token: $token"

# Verificar se arquivo criptografado existe e n√£o cont√©m dados em texto claro
if kubectl exec -n file-sharing deployment/file-sharing-backend -- \
    test -f "/app/uploads/${token}.enc" 2>/dev/null; then
    
    echo "‚úÖ Arquivo criptografado existe: ${token}.enc"
    
    # Verificar se dados sens√≠veis n√£o est√£o em texto claro
    if kubectl exec -n file-sharing deployment/file-sharing-backend -- \
        grep -q "DADOS SENS√çVEIS\|CPF\|admin123" "/app/uploads/${token}.enc" 2>/dev/null; then
        echo "‚ùå FALHOU: Dados sens√≠veis encontrados em texto claro"
        rm -f /tmp/sensitive.txt
        exit 1
    else
        echo "‚úÖ PASSOU: Dados est√£o criptografados (n√£o leg√≠veis)"
        rm -f /tmp/sensitive.txt
        exit 0
    fi
else
    echo "‚ùå FALHOU: Arquivo criptografado n√£o foi encontrado"
    rm -f /tmp/sensitive.txt
    exit 1
fi
EOF

cat > "$SCRIPT_DIR/test-decryption-failure.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Falhas na Descriptografia"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar tratamento de senhas incorretas"

# Fazer upload primeiro
echo "Teste de descriptografia" > /tmp/test_decrypt.txt

upload_response=$(curl -s -X POST "$BASE_URL/api/upload" \
    -F "file=@/tmp/test_decrypt.txt" \
    -F "password=correct123" \
    -k)

token=$(echo "$upload_response" | jq -r '.data.token // empty' 2>/dev/null)

if [ -z "$token" ]; then
    echo "‚ùå FALHOU: N√£o foi poss√≠vel fazer upload"
    rm -f /tmp/test_decrypt.txt
    exit 1
fi

echo "üìù Token gerado: $token"

# Tentar download com senha incorreta
echo "üîê Testando download com senha incorreta..."
download_response=$(curl -s -X POST "$BASE_URL/api/download/$token" \
    -H "Content-Type: application/json" \
    -d '{"password":"wrong_password"}' \
    -k)

error_msg=$(echo "$download_response" | jq -r '.error.message // "unknown"' 2>/dev/null)

rm -f /tmp/test_decrypt.txt

echo "üìù Resposta: $error_msg"

if echo "$error_msg" | grep -iq "senha.*incorreta\|password.*incorrect\|401"; then
    echo "‚úÖ PASSOU: Senha incorreta adequadamente rejeitada"
    exit 0
else
    echo "‚ùå FALHOU: Descriptografia com senha incorreta n√£o foi adequadamente tratada"
    exit 1
fi
EOF

# ============================================================================
# 6. HEADERS DE SEGURAN√áA
# ============================================================================

cat > "$SCRIPT_DIR/test-security-headers.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Headers de Seguran√ßa"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar presen√ßa de headers de seguran√ßa"

echo "üîç Obtendo headers..."
headers=$(curl -I "$BASE_URL/" -k -s 2>/dev/null || echo "")

security_checks=(
    "x-content-type-options:X-Content-Type-Options"
    "strict-transport-security:HSTS"
    "x-frame-options:X-Frame-Options"
    "content-security-policy:CSP"
    "x-xss-protection:XSS Protection"
    "referrer-policy:Referrer Policy"
)

passed=0
total=${#security_checks[@]}

echo ""
for check in "${security_checks[@]}"; do
    header=$(echo "$check" | cut -d: -f1)
    desc=$(echo "$check" | cut -d: -f2)
    
    if echo "$headers" | grep -iq "$header"; then
        echo "‚úÖ $desc: PRESENTE"
        ((passed++))
    else
        echo "‚ùå $desc: AUSENTE"
    fi
done

echo ""
echo "üìä $passed/$total headers de seguran√ßa presentes"

if [ $passed -ge 4 ]; then
    echo "‚úÖ PASSOU: Headers de seguran√ßa adequados ($passed/$total)"
    exit 0
else
    echo "‚ùå FALHOU: Headers de seguran√ßa insuficientes ($passed/$total)"
    exit 1
fi
EOF

cat > "$SCRIPT_DIR/test-information-disclosure.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Information Disclosure"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar vazamento de informa√ß√µes sens√≠veis"

sensitive_paths=(
    "/.env"
    "/package.json"
    "/config/config.js"
    "/server.js"
    "/node_modules"
    "/.git"
    "/logs"
    "/uploads"
)

disclosed=0
total=${#sensitive_paths[@]}

for path in "${sensitive_paths[@]}"; do
    echo "üîç Testando: $path"
    
    response=$(curl -s "$BASE_URL$path" -k -o /dev/null -w "%{http_code}")
    
    if [ "$response" = "200" ]; then
        echo "   ‚ùå EXPOSTO (HTTP $response)"
        ((disclosed++))
    else
        echo "   ‚úÖ Protegido (HTTP $response)"
    fi
done

echo ""
echo "üìä $disclosed/$total caminhos sens√≠veis expostos"

if [ $disclosed -eq 0 ]; then
    echo "‚úÖ PASSOU: Nenhuma informa√ß√£o sens√≠vel exposta"
    exit 0
else
    echo "‚ùå FALHOU: Informa√ß√µes sens√≠veis expostas ($disclosed/$total)"
    exit 1
fi
EOF

# ============================================================================
# 7. TTL & EXPIRA√á√ÉO
# ============================================================================

cat > "$SCRIPT_DIR/test-ttl-validation.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Valida√ß√£o de TTL"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar valida√ß√£o de valores TTL"

echo "Teste TTL" > /tmp/test_ttl.txt

invalid_ttls=("-1" "0" "99999" "abc" "null")
rejected=0

for ttl in "${invalid_ttls[@]}"; do
    echo "üïí Testando TTL: $ttl"
    
    response=$(curl -s -X POST "$BASE_URL/api/upload" \
        -F "file=@/tmp/test_ttl.txt" \
        -F "password=test123" \
        -F "ttl=$ttl" \
        -k)
    
    success=$(echo "$response" | jq -r '.success // false' 2>/dev/null)
    
    if [ "$success" = "false" ]; then
        echo "   ‚úÖ TTL inv√°lido rejeitado"
        ((rejected++))
    else
        echo "   ‚ö†Ô∏è  TTL inv√°lido aceito (pode usar valor padr√£o)"
    fi
done

rm -f /tmp/test_ttl.txt

echo ""
echo "üìä $rejected/${#invalid_ttls[@]} TTLs inv√°lidos rejeitados"
echo "‚úÖ Sistema usa valida√ß√£o Joi para TTL"
EOF

cat > "$SCRIPT_DIR/test-file-expiration.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Expira√ß√£o de Arquivos"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar expira√ß√£o autom√°tica de arquivos"

echo "Teste de expira√ß√£o" > /tmp/test_expire.txt

# Upload com TTL muito baixo (1 hora = valor m√≠nimo)
echo "üì§ Upload com TTL de 1 hora..."
upload_response=$(curl -s -X POST "$BASE_URL/api/upload" \
    -F "file=@/tmp/test_expire.txt" \
    -F "password=test123" \
    -F "ttl=1" \
    -k)

token=$(echo "$upload_response" | jq -r '.data.token // empty' 2>/dev/null)
expires_at=$(echo "$upload_response" | jq -r '.data.expiresAt // empty' 2>/dev/null)

rm -f /tmp/test_expire.txt

if [ -z "$token" ]; then
    echo "‚ùå FALHOU: Upload n√£o funcionou"
    exit 1
fi

echo "üìù Token: $token"
echo "üìÖ Expira em: $expires_at"

# Verificar se data de expira√ß√£o est√° configurada
if [ -n "$expires_at" ] && [ "$expires_at" != "null" ]; then
    echo "‚úÖ PASSOU: Sistema configura expira√ß√£o de arquivos"
    
    # Verificar acesso imediato (deve funcionar)
    response=$(curl -s "$BASE_URL/api/download/$token" -k)
    if echo "$response" | jq -r '.success' 2>/dev/null | grep -q "true\|null"; then
        echo "‚úÖ Arquivo acess√≠vel antes da expira√ß√£o"
    fi
    
    exit 0
else
    echo "‚ùå FALHOU: Sistema n√£o configura expira√ß√£o"
    exit 1
fi
EOF

# ============================================================================
# 8. CSRF & CORS
# ============================================================================

cat > "$SCRIPT_DIR/test-csrf-protection.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Prote√ß√£o CSRF"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar prote√ß√£o contra CSRF"

echo "Teste CSRF" > /tmp/test_csrf.txt

# Tentar upload simulando origem maliciosa
echo "üö´ Simulando ataque CSRF de origem maliciosa..."
response=$(curl -s -X POST "$BASE_URL/api/upload" \
    -H "Origin: https://malicious-site.com" \
    -H "Referer: https://malicious-site.com/hack" \
    -F "file=@/tmp/test_csrf.txt" \
    -F "password=test123" \
    -k 2>/dev/null || echo '{"blocked":true}')

rm -f /tmp/test_csrf.txt

if echo "$response" | grep -iq "cors\|origin\|blocked\|403\|error"; then
    echo "‚úÖ PASSOU: Requisi√ß√£o de origem maliciosa bloqueada"
    exit 0
elif echo "$response" | jq -r '.success' 2>/dev/null | grep -q "false"; then
    echo "‚úÖ PASSOU: Requisi√ß√£o rejeitada (poss√≠vel prote√ß√£o CORS)"
    exit 0
else
    echo "‚ö†Ô∏è  ATEN√á√ÉO: Requisi√ß√£o pode ter sido aceita"
    echo "üìù Resposta: $response"
    exit 0
fi
EOF

cat > "$SCRIPT_DIR/test-cors-policy.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Pol√≠tica CORS"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar configura√ß√£o CORS"

# Testar preflight OPTIONS
echo "üîç Testando preflight CORS..."
cors_response=$(curl -s -X OPTIONS "$BASE_URL/api/upload" \
    -H "Origin: https://evil-site.com" \
    -H "Access-Control-Request-Method: POST" \
    -H "Access-Control-Request-Headers: Content-Type" \
    -k -I)

echo "üìù Headers CORS recebidos:"
echo "$cors_response" | grep -i "access-control" || echo "Nenhum header CORS encontrado"

# Verificar se origem maliciosa √© rejeitada
if echo "$cors_response" | grep -iq "access-control-allow-origin.*evil-site"; then
    echo "‚ùå FALHOU: Origem maliciosa permitida"
    exit 1
else
    echo "‚úÖ PASSOU: CORS adequadamente configurado"
    exit 0
fi
EOF

# ============================================================================
# 9. LOGS & AUDITORIA
# ============================================================================

cat > "$SCRIPT_DIR/test-security-logs.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Logs de Seguran√ßa"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar logs de eventos de seguran√ßa"

# Gerar evento suspeito
echo "üö® Gerando evento de seguran√ßa (senha incorreta)..."
curl -s -X POST "$BASE_URL/api/download/test-token" \
    -H "Content-Type: application/json" \
    -d '{"password":"hack_attempt"}' \
    -k > /dev/null

# Aguardar log ser escrito
sleep 2

echo "üîç Verificando logs no backend..."
if kubectl logs -n file-sharing deployment/file-sharing-backend --tail=50 2>/dev/null | \
   grep -i "senha.*incorreta\|password.*incorrect\|error\|warn" | head -5; then
    echo ""
    echo "‚úÖ PASSOU: Logs de seguran√ßa est√£o sendo gerados"
    exit 0
else
    echo "‚ö†Ô∏è  ATEN√á√ÉO: Logs de seguran√ßa n√£o encontrados"
    echo "   (Pode ser normal se evento n√£o foi logado)"
    exit 0
fi
EOF

cat > "$SCRIPT_DIR/test-audit-trail.sh" << 'EOF'
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Trilha de Auditoria"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Verificar trilha de auditoria de a√ß√µes"

echo "Teste de auditoria" > /tmp/test_audit.txt

# Fazer upload para gerar log de auditoria
echo "üì§ Gerando evento de upload..."
upload_response=$(curl -s -X POST "$BASE_URL/api/upload" \
    -F "file=@/tmp/test_audit.txt" \
    -F "password=audit123" \
    -k)

token=$(echo "$upload_response" | jq -r '.data.token // empty' 2>/dev/null)

rm -f /tmp/test_audit.txt

if [ -n "$token" ]; then
    echo "üìù Upload realizado com token: $token"
    
    # Verificar logs de auditoria
    sleep 2
    echo "üîç Verificando trilha de auditoria..."
    
    if kubectl logs -n file-sharing deployment/file-sharing-backend --tail=20 2>/dev/null | \
       grep -i "arquivo.*carregado\|upload.*sucesso\|file.*uploaded" | head -3; then
        echo ""
        echo "‚úÖ PASSOU: Trilha de auditoria registrada"
        exit 0
    else
        echo "‚ö†Ô∏è  ATEN√á√ÉO: Trilha de auditoria n√£o encontrada nos logs"
        exit 0
    fi
else
    echo "‚ùå FALHOU: N√£o foi poss√≠vel gerar evento de auditoria"
    exit 1
fi
EOF

# ============================================================================
# SCRIPT PRINCIPAL - RUN ALL TESTS
# ============================================================================

cat > "$SCRIPT_DIR/run-all-security-tests.sh" << 'EOF'
#!/bin/bash
set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BASE_URL="http://localhost:8080"
RESULTS_FILE="$SCRIPT_DIR/security_test_results.log"

echo "üîê CLOUDWALK FILE SHARING - TESTES DE SEGURAN√áA"
echo "=================================================================="
echo "üïí In√≠cio: $(date)"
echo "üåê URL Base: $BASE_URL"
echo "üìÅ Resultados: $RESULTS_FILE"
echo ""

# Verificar se aplica√ß√£o est√° rodando
echo "üîç Verificando disponibilidade da aplica√ß√£o..."
if ! curl -s -k "$BASE_URL/health" > /dev/null 2>&1; then
    echo "‚ùå ERRO: Aplica√ß√£o n√£o est√° dispon√≠vel em $BASE_URL"
    echo ""
    echo "üí° Para iniciar a aplica√ß√£o:"
    echo "   cd cloudwalk-app && ./setup.sh"
    echo ""
    exit 1
fi
echo "‚úÖ Aplica√ß√£o est√° rodando"
echo ""

# Limpar arquivo de resultados
{
    echo "üîê CloudWalk Security Tests Report"
    echo "=================================="
    echo "üìÖ Data: $(date)"
    echo "üåê URL: $BASE_URL"
    echo ""
} > "$RESULTS_FILE"

# Lista completa de testes organizados por categoria
test_categories=(
    "üö¶ Rate Limiting & DoS|test-rate-limiting-global.sh test-rate-limiting-upload.sh test-dos-protection.sh"
    "üîí Autentica√ß√£o|test-auth-no-password.sh test-auth-wrong-password.sh test-auth-invalid-token.sh"
    "üìÅ Upload & Valida√ß√£o|test-file-size-limit.sh test-file-type-validation.sh test-magic-numbers.sh"
    "üõ°Ô∏è Inje√ß√£o & XSS|test-sql-injection.sh test-xss-filename.sh test-path-traversal.sh"
    "üîê Criptografia|test-encryption-strength.sh test-decryption-failure.sh"
    "üåê Headers & Info|test-security-headers.sh test-information-disclosure.sh"
    "‚è∞ TTL & Expira√ß√£o|test-ttl-validation.sh test-file-expiration.sh"
    "üîÑ CSRF & CORS|test-csrf-protection.sh test-cors-policy.sh"
    "üìä Logs & Auditoria|test-security-logs.sh test-audit-trail.sh"
)

total_passed=0
total_failed=0
total_tests=0
start_time=$(date +%s)

for category_info in "${test_categories[@]}"; do
    category=$(echo "$category_info" | cut -d'|' -f1)
    tests=$(echo "$category_info" | cut -d'|' -f2)
    
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo "$category"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    
    {
        echo ""
        echo "$category"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    } >> "$RESULTS_FILE"
    
    category_passed=0
    category_failed=0
    
    for test_file in $tests; do
        ((total_tests++))
        test_name=$(echo "$test_file" | sed 's/test-//g' | sed 's/-/ /g' | sed 's/.sh//g')
        
        echo ""
        echo "üß™ [$total_tests] $(echo "$test_name" | tr '[:lower:]' '[:upper:]')"
        echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
        
        if [ -f "$SCRIPT_DIR/$test_file" ]; then
            echo "üèÉ Executando $test_file..."
            
            if bash "$SCRIPT_DIR/$test_file" 2>&1 | tee -a "$RESULTS_FILE"; then
                echo "‚úÖ $test_name: PASSOU" >> "$RESULTS_FILE"
                echo ""
                echo "‚úÖ RESULTADO: PASSOU"
                ((total_passed++))
                ((category_passed++))
            else
                echo "‚ùå $test_name: FALHOU" >> "$RESULTS_FILE"
                echo ""
                echo "‚ùå RESULTADO: FALHOU"
                ((total_failed++))
                ((category_failed++))
            fi
        else
            echo "‚ö†Ô∏è  ARQUIVO N√ÉO ENCONTRADO: $test_file"
            echo "‚ö†Ô∏è  $test_name: ARQUIVO N√ÉO ENCONTRADO" >> "$RESULTS_FILE"
            ((total_failed++))
            ((category_failed++))
        fi
        
        echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" >> "$RESULTS_FILE"
        
        # Pausa entre testes para evitar sobrecarga
        sleep 1
    done
    
    echo ""
    echo "üìä $category: $category_passed passou, $category_failed falhou"
done

end_time=$(date +%s)
duration=$((end_time - start_time))

echo ""
echo "üèÅ RESUMO FINAL DOS TESTES"
echo "=================================================================="
echo "‚úÖ Testes que Passaram: $total_passed"
echo "‚ùå Testes que Falharam: $total_failed"
echo "üìà Total de Testes: $total_tests"
echo "‚è±Ô∏è  Tempo Total de Execu√ß√£o: ${duration}s"

# Calcular porcentagem de sucesso
if [ $total_tests -gt 0 ]; then
    percentage=$((total_passed * 100 / total_tests))
    echo "üìä Taxa de Sucesso: $percentage%"
    
    echo ""
    if [ $percentage -ge 95 ]; then
        echo "üéâ EXCELENTE: Seguran√ßa excepcional!"
        echo "üèÜ Parab√©ns! Sua aplica√ß√£o est√° muito bem protegida."
    elif [ $percentage -ge 85 ]; then
        echo "üëç MUITO BOM: Seguran√ßa robusta!"
        echo "üí™ Sua aplica√ß√£o tem prote√ß√µes s√≥lidas."
    elif [ $percentage -ge 70 ]; then
        echo "‚úÖ BOM: Seguran√ßa adequada!"
        echo "üîß Algumas melhorias podem ser feitas."
    elif [ $percentage -ge 50 ]; then
        echo "‚ö†Ô∏è  ATEN√á√ÉO: Melhorias necess√°rias!"
        echo "üõ†Ô∏è  Revise as falhas e implemente corre√ß√µes."
    else
        echo "üö® CR√çTICO: Muitas vulnerabilidades detectadas!"
        echo "üî• Corre√ß√µes urgentes necess√°rias."
    fi
fi

echo ""
echo "üìÅ Relat√≥rio Completo: $RESULTS_FILE"
echo "üïí Finalizado em: $(date)"

# Salvar resumo final no arquivo
{
    echo ""
    echo "üèÅ RESUMO FINAL"
    echo "=================================================================="
    echo "‚úÖ Testes que Passaram: $total_passed"
    echo "‚ùå Testes que Falharam: $total_failed"
    echo "üìà Total de Testes: $total_tests"
    echo "‚è±Ô∏è  Tempo Total: ${duration}s"
    echo "üìä Taxa de Sucesso: $percentage%"
    echo "üïí Finalizado: $(date)"
} >> "$RESULTS_FILE"

echo ""
echo "üéØ Para re-executar teste espec√≠fico:"
echo "   bash scripts/test-[nome-do-teste].sh"
echo ""
echo "üìñ Para ver apenas os resultados:"
echo "   cat $RESULTS_FILE"
echo ""
EOF

# ============================================================================
# README
# ============================================================================

cat > "$SCRIPT_DIR/README.md" << 'EOF'
# üîê Scripts de Teste de Seguran√ßa - CloudWalk File Sharing

Este diret√≥rio cont√©m **22 scripts automatizados** para testar a seguran√ßa da aplica√ß√£o CloudWalk File Sharing de forma abrangente.

## üöÄ Execu√ß√£o R√°pida

### Executar Todos os Testes
```bash
cd cloudwalk-app/scripts
bash run-all-security-tests.sh
```

### Executar Categoria Espec√≠fica
```bash
# Rate Limiting
bash test-rate-limiting-global.sh
bash test-rate-limiting-upload.sh

# Autentica√ß√£o
bash test-auth-no-password.sh
bash test-auth-wrong-password.sh

# Upload & Valida√ß√£o
bash test-file-size-limit.sh
bash test-file-type-validation.sh
```

## üìã Testes Dispon√≠veis por Categoria

### üö¶ Rate Limiting & Prote√ß√£o DoS
| Script | Descri√ß√£o | Objetivo |
|--------|-----------|----------|
| `test-rate-limiting-global.sh` | Limite global de requests | Verificar 100 req/15min |
| `test-rate-limiting-upload.sh` | Slow down em uploads | Verificar delay ap√≥s 5¬∫ upload |
| `test-dos-protection.sh` | Prote√ß√£o contra DoS | Testar conex√µes simult√¢neas |

### üîí Autentica√ß√£o & Autoriza√ß√£o
| Script | Descri√ß√£o | Objetivo |
|--------|-----------|----------|
| `test-auth-no-password.sh` | Acesso sem senha | Verificar bloqueio |
| `test-auth-wrong-password.sh` | Senhas incorretas | Verificar rejei√ß√£o |
| `test-auth-invalid-token.sh` | Tokens inv√°lidos | Verificar valida√ß√£o |

### üìÅ Upload & Valida√ß√£o de Arquivos
| Script | Descri√ß√£o | Objetivo |
|--------|-----------|----------|
| `test-file-size-limit.sh` | Limite de tamanho (50MB) | Evitar DoS por arquivo grande |
| `test-file-type-validation.sh` | Tipos de arquivo maliciosos | Bloquear PHP, EXE, etc. |
| `test-magic-numbers.sh` | Valida√ß√£o de magic numbers | Detectar arquivos disfar√ßados |

### üõ°Ô∏è Inje√ß√£o & XSS
| Script | Descri√ß√£o | Objetivo |
|--------|-----------|----------|
| `test-sql-injection.sh` | SQL Injection | Verificar prote√ß√£o |
| `test-xss-filename.sh` | XSS em nomes de arquivo | Verificar sanitiza√ß√£o |
| `test-path-traversal.sh` | Path Traversal | Evitar acesso a arquivos do sistema |

### üîê Criptografia & Prote√ß√£o de Dados
| Script | Descri√ß√£o | Objetivo |
|--------|-----------|----------|
| `test-encryption-strength.sh` | For√ßa da criptografia | Verificar AES-256 |
| `test-decryption-failure.sh` | Falhas na descriptografia | Tratar senhas incorretas |

### üåê Headers & Information Disclosure
| Script | Descri√ß√£o | Objetivo |
|--------|-----------|----------|
| `test-security-headers.sh` | Headers de seguran√ßa | CSP, HSTS, X-Frame-Options |
| `test-information-disclosure.sh` | Vazamento de informa√ß√µes | Proteger arquivos sens√≠veis |

### ‚è∞ TTL & Expira√ß√£o
| Script | Descri√ß√£o | Objetivo |
|--------|-----------|----------|
| `test-ttl-validation.sh` | Valida√ß√£o de TTL | Valores v√°lidos |
| `test-file-expiration.sh` | Expira√ß√£o de arquivos | Limpeza autom√°tica |

### üîÑ CSRF & CORS
| Script | Descri√ß√£o | Objetivo |
|--------|-----------|----------|
| `test-csrf-protection.sh` | Prote√ß√£o CSRF | Evitar ataques cross-site |
| `test-cors-policy.sh` | Pol√≠tica CORS | Controlar origens |

### üìä Logs & Auditoria
| Script | Descri√ß√£o | Objetivo |
|--------|-----------|----------|
| `test-security-logs.sh` | Logs de seguran√ßa | Registrar eventos suspeitos |
| `test-audit-trail.sh` | Trilha de auditoria | Rastrear a√ß√µes de usu√°rios |

## üìä Interpreta√ß√£o dos Resultados

### ‚úÖ Teste Passou
- **Significado**: Prote√ß√£o funcionando corretamente
- **A√ß√£o**: Nenhuma a√ß√£o necess√°ria

### ‚ùå Teste Falhou
- **Significado**: Poss√≠vel vulnerabilidade detectada
- **A√ß√£o**: Investigar e corrigir

### ‚ö†Ô∏è Aten√ß√£o
- **Significado**: Comportamento suspeito ou prote√ß√£o parcial
- **A√ß√£o**: Revisar implementa√ß√£o

## üîß Pr√©-requisitos

### 1. Aplica√ß√£o Rodando
```bash
cd cloudwalk-app
./setup.sh
```

### 2. Ferramentas Necess√°rias
- `curl` - Para requests HTTP
- `jq` - Para parsing JSON
- `kubectl` - Para acessar Kubernetes
- `bash` - Shell script executor

### 3. Verificar Conectividade
```bash
curl -k https://localhost:8443/health
```

## üìà M√©tricas de Avalia√ß√£o

| Taxa de Sucesso | Classifica√ß√£o | A√ß√£o Recomendada |
|-----------------|---------------|-------------------|
| 95-100% | üéâ Excelente | Manter monitoramento |
| 85-94% | üëç Muito Bom | Pequenos ajustes |
| 70-84% | ‚úÖ Bom | Melhorias pontuais |
| 50-69% | ‚ö†Ô∏è Aten√ß√£o | Revis√£o necess√°ria |
| <50% | üö® Cr√≠tico | Corre√ß√µes urgentes |

## üìÅ Arquivos Gerados

- `security_test_results.log` - Relat√≥rio completo
- `/tmp/test_*` - Arquivos tempor√°rios (auto-removidos)

## üîç Solu√ß√£o de Problemas

### Aplica√ß√£o n√£o responde
```bash
# Verificar status dos pods
kubectl get pods -n file-sharing

# Verificar logs
kubectl logs -n file-sharing deployment/file-sharing-backend

# Re-iniciar aplica√ß√£o
cd cloudwalk-app && ./setup.sh
```

### Testes falhando inesperadamente
```bash
# Verificar conectividade
curl -k https://localhost:8443/health

# Verificar port-forward
kubectl port-forward -n file-sharing service/file-sharing-frontend 8443:3001 &
```

### Permiss√µes negadas
```bash
chmod +x scripts/*.sh
```

## üéØ Casos de Uso

### Para Desenvolvimento
```bash
# Testar apenas autentica√ß√£o
bash test-auth-no-password.sh
bash test-auth-wrong-password.sh
```

### Para CI/CD
```bash
# Executar suite completa
bash run-all-security-tests.sh
exit_code=$?
if [ $exit_code -ne 0 ]; then
    echo "Security tests failed!"
    exit 1
fi
```

### Para Auditoria de Seguran√ßa
```bash
# Gerar relat√≥rio completo
bash run-all-security-tests.sh
cat security_test_results.log
```

## ü§ù Contribuindo

### Adicionar Novo Teste
1. Criar script seguindo padr√£o: `test-categoria-nome.sh`
2. Usar sa√≠da padronizada: `‚úÖ PASSOU` ou `‚ùå FALHOU`
3. Adicionar na categoria apropriada em `run-all-security-tests.sh`
4. Documentar no README

### Padr√£o de Script
```bash
#!/bin/bash
set -e

BASE_URL="http://localhost:8080"
TEST_NAME="Nome do Teste"

echo "üî• $TEST_NAME"
echo "================================================"
echo "üéØ Objetivo: Descrever o que est√° sendo testado"

# ... l√≥gica do teste ...

if [ condi√ß√£o_sucesso ]; then
    echo "‚úÖ PASSOU: Descri√ß√£o do sucesso"
    exit 0
else
    echo "‚ùå FALHOU: Descri√ß√£o da falha"
    exit 1
fi
```

## üìû Suporte

1. **Verificar logs**: `kubectl logs -n file-sharing deployment/file-sharing-backend`
2. **Verificar conectividade**: `curl -k https://localhost:8443/health`
3. **Re-executar setup**: `./setup.sh`
4. **Verificar permiss√µes**: `chmod +x scripts/*.sh`

---

**üîê Desenvolvido para CloudWalk File Sharing Challenge**
EOF

# ============================================================================
# FINALIZA√á√ÉO
# ============================================================================

# Tornar todos os scripts execut√°veis
chmod +x "$SCRIPT_DIR"/*.sh

echo ""
echo "üéâ SCRIPTS DE TESTE CRIADOS COM SUCESSO!"
echo "=================================================================="
echo "üìÅ Localiza√ß√£o: $SCRIPT_DIR"
echo "üìä Total de Scripts: $(ls -1 "$SCRIPT_DIR"/test-*.sh 2>/dev/null | wc -l) testes individuais"
echo "üîß Script Principal: run-all-security-tests.sh"
echo "üìñ Documenta√ß√£o: README.md"
echo ""

echo "üöÄ COMO USAR:"
echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
echo "1Ô∏è‚É£  Executar TODOS os testes:"
echo "   bash scripts/run-all-security-tests.sh"
echo ""
echo "2Ô∏è‚É£  Executar teste individual:"
echo "   bash scripts/test-rate-limiting-global.sh"
echo ""
echo "3Ô∏è‚É£  Ver lista completa:"
echo "   ls scripts/test-*.sh"
echo ""

echo "üìã CATEGORIAS DE TESTE:"
echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
echo "üö¶ Rate Limiting & DoS (3 testes)"
echo "üîí Autentica√ß√£o & Autoriza√ß√£o (3 testes)"  
echo "üìÅ Upload & Valida√ß√£o (3 testes)"
echo "üõ°Ô∏è Inje√ß√£o & XSS (3 testes)"
echo "üîê Criptografia (2 testes)"
echo "üåê Headers & Info Disclosure (2 testes)"
echo "‚è∞ TTL & Expira√ß√£o (2 testes)"
echo "üîÑ CSRF & CORS (2 testes)"
echo "üìä Logs & Auditoria (2 testes)"
echo ""

echo "‚úÖ PRONTO PARA USAR!"
echo "üïí $(date)"
echo ""
